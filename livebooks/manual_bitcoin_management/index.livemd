# Manual Bitcoin Management Example

```elixir
Mix.install([
  {:bitcoinlib, "~> 0.2.0-pre2"}
])

alias BitcoinLib.Key.{PrivateKey, PublicKey, PublicKeyHash, Address}
alias BitcoinLib.Key.HD.MnemonicSeed
alias BitcoinLib.Transaction
```

## Keys and addresses creation

🎲 Create a mnemonic seed from dice rolls

```elixir
{:ok, mnemonic_phrase} =
  MnemonicSeed.wordlist_from_dice_rolls("12345612345612345612345612345612345612345612345612")
```

🔑 Derive the master private key from the mnemonic seed

```elixir
master_private_key = PrivateKey.from_mnemonic_phrase(mnemonic_phrase)
```

Derive private key and extract a create P2PKH public key hash that will be useful later

```elixir
receive_public_key_hash =
  master_private_key
  |> PrivateKey.from_derivation_path!("m/44'/1'/0'/0/0")
  |> PublicKey.from_private_key()
  |> PublicKeyHash.from_public_key()
```

Convert the public key hash to an address, which will be needed by faucets to receive funds

```elixir
receive_address = Address.from_public_key_hash(receive_public_key_hash, :p2pkh, :testnet)
```

## Get some tBTC

### 👁️ Monitor the address

Go to `mempool.space` by directly forging the URL with the address and wait transactions being confirmed.

Ex: `https://mempool.space/testnet/address/mwuh4ikLxAqQfSBEYVDiwdrfEVBKw8h98x`

Now leave that browser tab lying around. Mempool is supposed to issue a cashier bell sound 🔔 when it detects new incoming transactions to that address. When funds become spendable, you'll also hear somewhat of a magic wand sound. 🪄

<!-- livebook:{"break_markdown":true} -->

### 🚰 Request some testnet Bitcoin from faucets

Go to a Bitcoin Testnet faucet and use the above address to request funds... any amount would do, even tiny fractions.

* [https://coinfaucet.eu/en/btc-testnet/](coinfaucet)
* [https://bitcoinfaucet.uo1.net/](uo1.net)
* [https://testnet.qc.to/](qc.to)
* [https://onchain.io/bitcoin-testnet-faucet](onchain.io)

Here is an example of 10000 testnet sats, or 0.0001 tBTC, being ready to spend with 14 confirmations.

![confirmed transaction](images/confirmed_transaction.png)

<!-- livebook:{"break_markdown":true} -->

### 🔎 View the transaction's details

Click on the transaction ID.

There is a `Inputs & Outputs` section, with inputs on the left and outputs in the right... here, our address is the first output. In computer science, `0` represents the first value, and we associate it to `vout`. This will be useful later to point to the right output inside the transaction, which happens to have two here.

Clicking on the `Details` button reveals this:

![transaction details](images/transaction_details.png)

Here lies the `script pub key`, also known as the `locking script`. This is what prevents funds from being spent, unless it is being used with the right parameters. That is exactly what's going to happen later.

The following code is defining variables containing what we just talked about.

```elixir
transaction_id = "420c552d7821da5da61be91dffe984537f460dc668f0766f6c2e1c7a10287610"
vout = 0
script_pub_key = Binary.from_hex("76a914b3ceddcbe5fa8aea1f672a4e543e57a49da179e388ac")
```

### How transactions work

The above `script pub key` is locking what we call a UTXO which stands for Unspent Transaction Output. The sum of all UTXOs in a wallet is what can be considered as the balance.

Spending from a UTXO invalidates it, creating new ones in the process.

The current UTXO contains `10000` sats. We intend to send `5000` sats to a new address. This leaves `5000` sats remaining. They must end up in two other destinations: `the change` and `the transaction fee`. The change is another UTXO and we'll keep `4000` sats. The fee is what's leftover and the miner who will include the transaction in a new block will keep it. It is thus implied from the three previous amounts:

<!-- livebook:{"force_markdown":true} -->

```elixir
original_amount = 10000
destination_amount = 5000
change = 4000
fee = 1000
```

Let's create two addresses: a `destination address` and a `change address`.

```elixir
destination_address =
  master_private_key
  |> PrivateKey.from_derivation_path!("m/44'/1'/0'/0/1")
  |> PublicKey.from_private_key()
  |> PublicKeyHash.from_public_key()
  |> Address.from_public_key_hash(:p2pkh, :testnet)
```

```elixir
change_address =
  master_private_key
  |> PrivateKey.from_derivation_path!("m/44'/1'/0'/1/1")
  |> PublicKey.from_private_key()
  |> PublicKeyHash.from_public_key()
  |> Address.from_public_key_hash(:p2pkh, :testnet)
```
